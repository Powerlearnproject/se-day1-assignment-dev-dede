[![Open in Visual Studio Code](https://classroom.github.com/assets/open-in-vscode-2e0aaae1b6195c2367325f4f02e2d04e9abb55f0b24a779b69b11b9e10269abc.svg)](https://classroom.github.com/online_ide?assignment_repo_id=18382642&assignment_repo_type=AssignmentRepo)
# SE_Day1
Software Engineering Day1 Assignment

#Part 1: Introduction to Software Engineering

Explain what software engineering is and discuss its importance in the technology industry.
Software engineering is about buiding user friendly applications to solve real world problems through technology


Identify and describe at least three key milestones in the evolution of software engineering.
1. The Birth of Software Engineering (1968). The term "software engineering" was first introduced at the NATO Software Engineering Conference.
2. The Rise of Object-Oriented Programming (OOP) (1970s-1980s). The shift from procedural programming (e.g., C) to object-oriented programming (e.g., C++, Java) improved code reusability
3. The Agile Revolution (2001-Present). The Agile Manifesto introduced a flexible, iterative approach to software development,


List and briefly explain the phases of the Software Development Life Cycle.
Planning – Define project scope, goals, risks, and feasibility.
Requirement Analysis – Gather and document functional and non-functional requirements.
Design – Create system architecture, database models, and UI/UX wireframes.
Implementation (Coding) – Develop the software based on design specifications.
Testing – Perform unit, integration, and system testing to detect bugs and ensure quality.
Deployment – Release the software to production or a staging environment.
Maintenance – Provide updates, bug fixes, and enhancements as needed.


Compare and contrast the Waterfall and Agile methodologies. Provide examples of scenarios where each would be appropriate.
| Feature        | Waterfall | Agile |
|---------------|----------|-------|
| **Process** | Linear, step-by-step | Iterative and flexible |
| **Requirement Changes** | Difficult to accommodate changes once a phase is complete | Can adapt to changing requirements at any stage |
| **Delivery** | Delivered at the end of development | Delivered in increments (sprints) |
| **Customer Involvement** | Minimal after initial planning | Continuous collaboration with customers |
| **Testing** | Happens at the end | Ongoing throughout development |


When to Use Waterfall: Projects with well-defined requirements and minimal expected changes (e.g., government projects, construction software).
When to Use Agile: Projects requiring flexibility, frequent updates, and customer feedback (e.g., mobile apps, startups, SaaS platforms).


Describe the roles and responsibilities of a Software Developer, a Quality Assurance Engineer, and a Project Manager in a software engineering team.
Software Developer: Writes, tests, and maintains code.
Quality Assurance (QA) Engineer:  Designs and executes test cases to find bugs, ensuring software meets functional and performance standards.
Project Manager (PM): Oversees project timelines, budgets, and resources and ensures software is delivered on time and meets requirements.
Communicates between stakeholders, developers, and clients.


Discuss the importance of Integrated Development Environments (IDEs) and Version Control Systems (VCS) in the software development process. Give examples of each.
IDEs provide a comprehensive set of tools to help software engineers write, test, and debug code efficiently. example, VS code
Version Control Systems (VCS) help track changes in code, collaborate with teams, and maintain project history. example, git


What are some common challenges faced by software engineers? Provide strategies to overcome these challenges.
Debugging Complex Code: Hard-to-trace bugs can slow down development.
Solution: Use IDE debuggers, logging tools, and systematic testing.
Scope Creep: Constantly changing requirements affect deadlines.
Solution: Use Agile methodology and maintain clear documentation.

Explain the different types of testing (unit, integration, system, and acceptance) and their importance in software quality assurance.
Unit Testing – Tests individual components or functions. Importance: Catches bugs early and ensures code reliability.
Integration Testing – Ensures that multiple components work together. Importance: Prevents issues when connecting modules or APIs.
System Testing – Tests the entire application as a whole. Importance: Validates that all requirements are met.
Acceptance Testing – Confirms if the system meets business needs. Importance: Ensures user satisfaction before deployment.

#Part 2: Introduction to AI and Prompt Engineering


Define prompt engineering and discuss its importance in interacting with AI models.
Prompt engineering is the practice of crafting effective inputs (prompts) to guide AI models in generating accurate and useful responses. It is crucial because:
Well-structured prompts improve AI accuracy.
Clear prompts minimize misinterpretation.


Provide an example of a vague prompt and then improve it by making it clear, specific, and concise. Explain why the improved prompt is more effective.
